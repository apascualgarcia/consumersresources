#!/bin/bash

# This script generates a file which, when run, computes the average dominant eigenvalue
# systems for every consumption matrix on the MATRIX_LIST file, with alpha in mode ALPHA_MODE,
# for every value of alpha0 in the ALPHA_VALS list, with the other metaparameters
# given in the configuration file CONFIGURATION_FILE.

# The file generated will be placed in the ./commands folder and named after
# the variable COMMAND_FILE

# Example for NR=NS=25
#!/bin/bash
# This script automatically computes and draws a graph max(eigenvalue) vs. alpha0
# for every matrix listed (one graph per matrix list) and alpha_mode chosen
MATRIX_LIST="full_rank_opt_consumption_mat_NR25_NS25"
ALPHA_MODE="optimal_matrix"
#ALPHA_MODE="random_structure"
SAVENAME="largest_eigenvalue_NR25_NS25_100_points"
OPTIMAL_MATRIX_FOLDER="9Jul21"
ADDITIONAL_MODIF="verbose-level=1"
ALPHA_VALS="0 0.0013 0.0026 0.0039 0.0052 0.0065 0.0078 0.0091 0.0104 0.014"
NR=25
NS=25
# for old version
# VOL_NAME="common_feasibility_volume_NR25_NS25"
COMMAND_FILE="test_feasibility_dynamical_stability_computations.txt"


for a in $ALPHA_MODE
do
  for matl in $MATRIX_LIST
  do
    for alpha in $ALPHA_VALS
    do
      CURRENT_NAME="${SAVENAME}_${matl}_${a}_${OPTIMAL_MATRIX_FOLDER}"
      VOLUME_PATH="${VOL_NAME}_${matl}_${a}_${OPTIMAL_MATRIX_FOLDER}"
      if [ ! -z "${ADDITIONAL_MODIF}" ]
      then
        for add in $ADDITIONAL_MODIF
        do
          CURRENT_NAME="${CURRENT_NAME}_${add}"
        done
      fi
      CURRENT_NAME="${CURRENT_NAME}_alpha0=${alpha}"
      VOLUME_PATH="${VOLUME_PATH}_alpha0=${alpha}"

      FIRST_COMMAND="build/compute_largest_eigenvalue_for_grid config/configuration.in path_to_save_file=data_output/${CURRENT_NAME}.out path_to_food_matrix=matrix_list/${matl}.in alpha_mode=${a} path_to_syntrophy_matrix=optimal_matrices/syntrophy/Nr_${NR}_Nc${25}/${OPTIMAL_MATRIX_FOLDER} alpha0=${alpha}  ${ADDITIONAL_MODIF}"
      # for old version
      # FIRST_COMMAND="${FIRST_COMMAND} path_to_volume='feasibility/${VOLUME_PATH}.out'"
      FIRST_COMMAND="${FIRST_COMMAND} | ts \"[%Y-%m-%d %H:%M:%S]\""

      COMMAND_NAME="${FIRST_COMMAND}"

      LOG_NAME="logs/${CURRENT_NAME}.log"
      ERR_LOG_NAME="logs/err_${CURRENT_NAME}.log"
      # execute command
      # nohup sh -c "${COMMAND_NAME}" >${LOG_NAME} 2>${ERR_LOG_NAME} &
      echo "${COMMAND_NAME} > ${LOG_NAME} 2>${ERR_LOG_NAME}" >> commands/${COMMAND_FILE}
      # write command to log
      now="["$(date)"]"
      echo "${now} nohup sh -c \"${COMMAND_NAME}\" >${LOG_NAME} 2>${ERR_LOG_NAME} &" >> logs/commands.log
    done
  done
done
